import{a as m,w as A}from"./vendor-8jHm-DXstvPfe.js";import{i as U}from"./vendor-7avT-DhdrFwTb.js";import{a as B}from"./vendor-UUu6-BeUS1t8s.js";import{r as v,u as F}from"./vendor-eqDO-Ti6p_k8X.js";import{c as Y,w as b,g as G}from"./vendor-RE7Z-DOm9JKld.js";function X(h){const f=v([]),r=v({}),q=v(16),g=v(!1),p=v({}),w=v("hasChildren"),C=v("children"),D=v(!1),c=G(),N=Y(()=>{if(!h.rowKey.value)return{};const e=h.data.value||[];return I(e)}),R=Y(()=>{const e=h.rowKey.value,n=Object.keys(p.value),a={};return n.length&&n.forEach(l=>{if(p.value[l].length){const o={children:[]};p.value[l].forEach(d=>{const s=m(d,e);o.children.push(s),d[w.value]&&!a[s]&&(a[s]={children:[]})}),a[l]=o}}),a}),I=e=>{const n=h.rowKey.value,a={};return A(e,(l,o,d)=>{const s=m(l,n);U(o)?a[s]={children:o.map(K=>m(K,n)),level:d}:g.value&&(a[s]={children:[],lazy:!0,level:d})},C.value,w.value),a},y=(e=!1,n=(a=>(a=c.store)==null?void 0:a.states.defaultExpandAll.value)())=>{var a;const l=N.value,o=R.value,d=Object.keys(l),s={};if(d.length){const K=F(r),T=[],j=(t,i)=>{if(e)return f.value?n||f.value.includes(i):!!(n||t!=null&&t.expanded);{const u=n||f.value&&f.value.includes(i);return!!(t!=null&&t.expanded||u)}};d.forEach(t=>{const i=K[t],u={...l[t]};if(u.expanded=j(i,t),u.lazy){const{loaded:E=!1,loading:x=!1}=i||{};u.loaded=!!E,u.loading=!!x,T.push(t)}s[t]=u});const S=Object.keys(o);g.value&&S.length&&T.length&&S.forEach(t=>{const i=K[t],u=o[t].children;if(T.includes(t)){if(s[t].children.length!==0)throw new Error("[ElTable]children must be an empty array.");s[t].children=u}else{const{loaded:E=!1,loading:x=!1}=i||{};s[t]={lazy:!0,loaded:!!E,loading:!!x,expanded:j(i,t),children:u,level:""}}})}r.value=s,(a=c.store)==null||a.updateTableScrollY()};b(()=>f.value,()=>{y(!0)}),b(()=>N.value,()=>{y()}),b(()=>R.value,()=>{y()});const M=e=>{f.value=e,y()},L=e=>g.value&&e&&"loaded"in e&&!e.loaded,O=(e,n)=>{c.store.assertRowKey();const a=h.rowKey.value,l=m(e,a),o=l&&r.value[l];if(l&&o&&"expanded"in o){const d=o.expanded;n=B(n)?!o.expanded:n,r.value[l].expanded=n,d!==n&&c.emit("expand-change",e,n),L(o)&&z(e,l,o),c.store.updateTableScrollY()}},_=e=>{c.store.assertRowKey();const n=h.rowKey.value,a=m(e,n),l=r.value[a];L(l)?z(e,a,l):O(e,void 0)},z=(e,n,a)=>{const{load:l}=c.props;l&&!r.value[n].loaded&&(r.value[n].loading=!0,l(e,a,o=>{if(!U(o))throw new TypeError("[ElTable] data must be an array");r.value[n].loading=!1,r.value[n].loaded=!0,r.value[n].expanded=!0,o.length&&(p.value[n]=o),c.emit("expand-change",e,!0)}))};return{loadData:z,loadOrToggle:_,toggleTreeExpansion:O,updateTreeExpandKeys:M,updateTreeData:y,updateKeyChildren:(e,n)=>{const{lazy:a,rowKey:l}=c.props;if(a){if(!l)throw new Error("[Table] rowKey is required in updateKeyChild");p.value[e]&&(p.value[e]=n)}},normalize:I,states:{expandRowKeys:f,treeData:r,indent:q,lazy:g,lazyTreeNodeMap:p,lazyColumnIdentifier:w,childrenColumnName:C,checkStrictly:D}}}export{X as u};
