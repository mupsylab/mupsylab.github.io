import{a as O}from"./vendor-8jHm-DXstvPfe.js";import{T as X}from"./vendor-ixTu-B_aMp52B.js";import{u as Z}from"./vendor-4yqK-CsLKzPvh.js";import{u as I}from"./vendor-IeHI-Bn0RHErW.js";import{T as D}from"./vendor-Axb2-CEDqGlH4.js";import{u as $}from"./vendor-unoq-CFxLHdLI.js";import{c as C,d as ee}from"./vendor-UUu6-BeUS1t8s.js";import{m as le}from"./vendor-W9GH-DUAmleCu.js";import{l as ne,c as te,n as K}from"./vendor-RE7Z-DOm9JKld.js";function ye(r){const T=ne(X),M=$("table"),{handleDoubleClick:S,handleClick:_,handleContextMenu:R,handleMouseEnter:j,handleMouseLeave:W,handleCellMouseEnter:q,handleCellMouseLeave:A,tooltipContent:B,tooltipTrigger:F}=Z(r),{getRowStyle:J,getRowClass:P,getCellStyle:Y,getCellClass:w,getSpan:G,getColspanRealWidth:H}=I(r),Q=te(()=>r.store.states.columns.value.findIndex(({type:l})=>l==="default")),b=(l,t)=>{const n=T.props.rowKey;return n?O(l,n):t},g=(l,t,n,z=!1)=>{const{tooltipEffect:L,tooltipOptions:p,store:E}=r,{indent:k,columns:f}=E.states,y=P(l,t);let N=!0;return n&&(y.push(M.em("row",`level-${n.level}`)),N=n.display),K("tr",{style:[N?null:{display:"none"},J(l,t)],class:y,key:b(l,t),onDblclick:e=>S(e,l),onClick:e=>_(e,l),onContextmenu:e=>R(e,l),onMouseenter:()=>j(t),onMouseleave:W},f.value.map((e,s)=>{const{rowspan:m,colspan:d}=G(l,e,t,s);if(!m||!d)return null;const i=Object.assign({},e);i.realWidth=H(f.value,d,s);const u={store:r.store,_self:r.context||T,column:i,row:l,$index:t,cellIndex:s,expanded:z};s===Q.value&&n&&(u.treeNode={indent:n.level*k.value,level:n.level},C(n.expanded)&&(u.treeNode.expanded=n.expanded,"loading"in n&&(u.treeNode.loading=n.loading),"noLazyChildren"in n&&(u.treeNode.noLazyChildren=n.noLazyChildren)));const v=`${b(l,t)},${s}`,c=i.columnKey||i.rawColumnKey||"",h=e.showOverflowTooltip&&le({effect:L},p,e.showOverflowTooltip);return K(D,{style:Y(t,s,l,e),class:w(t,s,l,e,d-1),key:`${c}${v}`,rowspan:m,colspan:d,onMouseenter:a=>q(a,l,h),onMouseleave:A},{default:()=>U(s,e,u)})}))},U=(l,t,n)=>t.renderCell(n);return{wrappedRowRender:(l,t)=>{const n=r.store,{isRowExpanded:z,assertRowKey:L}=n,{treeData:p,lazyTreeNodeMap:E,childrenColumnName:k,rowKey:f}=n.states,y=n.states.columns.value;if(y.some(({type:o})=>o==="expand")){const o=z(l),e=g(l,t,void 0,o),s=T.renderExpanded;return o?s?[[e,K("tr",{key:`expanded-row__${e.key}`},[K("td",{colspan:y.length,class:`${M.e("cell")} ${M.e("expanded-cell")}`},[s({row:l,$index:t,store:n,expanded:o})])])]]:(console.error("[Element Error]renderExpanded is required."),e):[[e]]}else if(Object.keys(p.value).length){L();const o=O(l,f.value);let e=p.value[o],s=null;e&&(s={expanded:e.expanded,level:e.level,display:!0},C(e.lazy)&&(C(e.loaded)&&e.loaded&&(s.noLazyChildren=!(e.children&&e.children.length)),s.loading=e.loading));const m=[g(l,t,s)];if(e){let d=0;const i=(v,c)=>{v&&v.length&&c&&v.forEach(h=>{const a={display:c.display&&c.expanded,level:c.level+1,expanded:!1,noLazyChildren:!1,loading:!1},x=O(h,f.value);if(ee(x))throw new Error("For nested data item, row-key is required.");if(e={...p.value[x]},e&&(a.expanded=e.expanded,e.level=e.level||a.level,e.display=!!(e.expanded&&a.display),C(e.lazy)&&(C(e.loaded)&&e.loaded&&(a.noLazyChildren=!(e.children&&e.children.length)),a.loading=e.loading)),d++,m.push(g(h,t+d,a)),e){const V=E.value[x]||h[k.value];i(V,e)}})};e.display=!0;const u=E.value[o]||l[k.value];i(u,e)}return m}else return g(l,t,void 0)},tooltipContent:B,tooltipTrigger:F}}export{ye as u};
